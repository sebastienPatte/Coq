(** Meta-programming in Coq **)

From Coq Require Import Utf8.
From Coq Require Import List Lia.
Import ListNotations.

Set Universe Polymorphism.

Axiom exercise : ∀ {A}, A.
Ltac exercise := apply exercise.

(** Let us start with some Ltac **)

(** Semicolon (;) is a bit more complicated than just sequential composition.

  First, t1 ; t2 applies t2 to all subgoals generated by t1.
  So split ; constructor will solve the goal nat * nat.

  Second, Ltac bakes in backtracking: each tactic can have several successes.
  For instance the constructor tactic has a success for each constructor that
  matches the goal.
**)

Goal bool.
Proof.
  constructor.
  Show Proof. (* It picks true *)
Qed.

Goal ∃ (b : bool), b = false.
Proof.
  (* unshelve eexists lets us give the witness first *)
  unshelve eexists.
  - constructor .
  - (* We're stuck now *)
    Fail constructor.
Restart.
  (* Note what happens if we didn't use unshelve *)
  eexists.
  (* We only have one goal, and the goal of type bool is *shelved*. *)
  (** There we could already solve the goal using reflexivity but that's
      not what I want to show you right now.
      So let's start over and use the semicolon.
  **)
Restart.
  unshelve eexists ; constructor.
  Show Proof.
  (* This time it picked false! *)
  (** Actually, it first picked true, but then constructor failed to
      prove true = false. So it went back and picked another success for
      the goal bool: false.
  **)
Restart.
  (** constructor doesn't work for exists because it can't guess the
      witness, but we can use econstructor instead to generate an existential
      variable to be filled later. When doing this, we can prove the goal with
      just a succession of econstructor.

      As before I use unshelve to make sure it asks us to also give the witness.
  **)
  unshelve econstructor ; econstructor.
Restart.
  repeat unshelve econstructor.
  (* repeat here doesn't work so repeat t is not the same as t ; repeat t. *)
  (* It applies t as long as it progresses: ie succeeds and changes the goal. *)
Abort.

(** Let us now use (lazy)match goal **)

Goal nat * bool * unit.
Proof.
  match goal with
  | |- ?A * ?B => idtac "we have first" A "then" B
  end.
  (** Note we use question marks to talk about unification variables.
      This is slightly different from Coq's usual pattern matching.
      Also remark that we are matching on a type here!
  **)
  (* idtac prints the arguments it is given. *)
  (** If you use VSCoq, it will not open the output automatically so you can
      use Ctrl/Cmd + Shift + U to do it, then select "Info" on the right to
      see the output of idtac.
  **)
  (* We see: we have first (nat * bool)%type then unit *)
  (* So now we know how products are associated. *)

  (* match goal backtracks when the tactic inside fails *)
  match goal with
  | |- ?A * ?B => fail (* The ideal tactic to fail *)
  | |- ?A * ?B * ?C => idtac C
  end.

  (* lazymatch goal doesn't backtrack in the branches *)
  Fail lazymatch goal with
  | |- ?A * ?B => fail "This is expected this time"
  | |- ?A * ?B * ?C => idtac C
  end.

  (* I recommend this, unless you really want backtracking! *)

  (* It also fails when none of the branches match *)
  Fail lazymatch goal with
  | |- nat => idtac
  end.

  (* We can use this to fill automatically the goal *)

  repeat lazymatch goal with
  | |- ?A * ?B => split
  | |- nat => exact 13
  | |- bool => exact false
  | |- unit => exact tt
  end.
  Show Proof.
Qed.

(* We can also define tactics at top level so we can use them many times. *)

Ltac split_or_apply :=
  match goal with
  | |- ?A ∧ ?B => split
  | h : ?B → ?A |- ?A => apply h
  end.

Lemma test : ∀ (A B : Prop), (A → B) → A ∧ B.
Proof.
  intros. (* No need to specify the names we won't be using them. *)
  split_or_apply.
  - Fail split_or_apply.
    admit.
  - split_or_apply.
Restart.
  intros.
  repeat split_or_apply.
Restart.
  intros.
  change (id (A ∧ B)). repeat split_or_apply.
  (* It only works syntactically! *)
  unfold id. change B with (id B).
  repeat split_or_apply. (* Except when it tries to unify things. *)
Abort.

(** Let's put it in practice, write a tactic that turns a goal of the form
    A₀ * A₁ * … * Aₙ
    into (n+1) goals A₀ to Aₙ.
*)

Ltac splits := match goal with 
  | |- ?A * ?B => split; splits 
  | |- _ => idtac
end.
(* Try it on these goals. *)

Goal nat * bool.
Proof.
  splits.
Abort.

Goal nat * (bool * unit) * (unit * nat * bool) * unit.
Proof.
  splits.
Abort.

(* Now write one that also handles ∀-quantifiers before. *)

Ltac introsplits := match goal with 
  | |- ∀ (_:_), _  => intro; introsplits
  | |- ?A * ?B => split; introsplits 
  | |- _ => idtac
end. 

Goal ∀ A B C D, A * B * C * D.
Proof.
  introsplits.
Abort.

(** Write a tactic that is a bit like assumption except it will also solve
    a goal G when one hypothesis is A → G and A also has a proof in scope.
**)

Ltac assumption2 := match goal with
  | H: ?A -> ?G, H2: ?A |- ?G => specialize (H H2); assumption2
  | H: ?G |- ?G => apply H
end.

Goal ∀ A, A → nat → A.
Proof.
  intros. assumption2.
Qed.

Goal ∀ n m, (n = 3 + 3 → n = m) → n = 6 → 0 + n = m.
Proof.
  intros. assumption2.
Qed.

(** Now let's look at classes **)

Class Monoid (A : Type) (neu : A) (op : A → A → A) := {
  m_left_neutral : ∀ x, op neu x = x ;
  m_right_neutral : ∀ x, op x neu = x ;
  m_assoc : ∀ x y z, op (op x y) z = op x (op y z)
}.

(* (ℕ,0,+) is a monoid, prove it *)
#[local] Instance MonoidNat : Monoid nat 0 plus.
Proof.
  split.
  - intro.  simpl. reflexivity.
  - intro. rewrite PeanoNat.Nat.add_0_r. reflexivity.
  - intros. intuition. 
Qed.

(* Some lemmas we can prove using only the monoid structure on (ℕ,0,+) *)
(* See how Coq infers which proofs we are talking about. *)
Lemma test_nat :
  ∀ k n m, k + n + m + 0 = k + (n + m).
Proof.
  intros.
  rewrite m_right_neutral.
  rewrite m_assoc. reflexivity.
Qed.

(* We can prove it in general on monoids *)
Lemma test_monoid :
  ∀ M neu op `{Monoid M neu op} k n m,
    op (op (op k n) m) neu = op k (op n m).
Proof.
  intros.
  rewrite m_right_neutral.
  rewrite m_assoc.
  reflexivity.
Qed.

Lemma test_nat' :
  ∀ k n m, k + n + m + 0 = k + (n + m).
Proof.
  intros. apply test_monoid.
  (* We need to give an instance of monoid for nat, but we're too lazy to find
    its name. It's supposed to infer it on its own! So we just give _ as the
    proof and Coq is fine with that.
  *)
  exact _.
Qed.

(* Lists also form a monoid *)
#[local] Instance MonoidList : ∀ A, Monoid (list A) [] (@app A).
Proof.
  constructor.
  - simpl. intro. reflexivity.
  - intro. apply app_nil_r.
  - intros. rewrite app_assoc. reflexivity.
Qed.

(* Prove the following using test_monoid *)
Lemma test_list :
  ∀ A (k n m : list A), ((k ++ n) ++ m) ++ [] = k ++ n ++ m.
Proof.
  intros.
  rewrite test_monoid.
  reflexivity.
  apply MonoidList.
Qed.

(* A product of monoids is also a monoid, fill in the missing bits. *)
#[local] Instance MonoidProd :
  ∀ A B na nb opa opb,
    Monoid A na opa →
    Monoid B nb opb →
    Monoid (A * B) (na ,nb) exercise.
Proof.
  intros.

Admitted.

Definition foo : Monoid (list bool * nat * list nat) _ _ := _.
Print foo.

(* Here is another example of class: decidable equality. *)

Class Eq A := {
  eqb : A → A → bool ;
  eqb_iff : ∀ x y, eqb x y = true ↔ x = y
}.

(** Complete the following function that tests whether an element is inside a
    list. Thanks to classes, we can define this function for all types with a
    decidable equality.
**)

Fixpoint memb {A} `{Eq A} (x : A) (l : list A) : bool := 
  match l with 
  |[] => false
  |h::t => if eqb x h then true else memb x t
  end.

(** Another example of type class is WellFounded that is used by Equations
    to get a proof that a relation is… well founded.
**)

From Equations Require Import Equations.

Print WellFounded.

(* Consider the following order on booleans. *)

Inductive lt_tf : bool → bool → Prop :=
| lt_true_false : lt_tf true false.

(* Prove it is well founded. *)

#[local] Instance wf_lt_tf : WellFounded lt_tf.
Proof.
  constructor.
  intros.
  constructor.
Admitted.

(** We can now define the following function. That corresponds to all bijections
    between bool and itself.
**)

Equations bbij (bij_true : bool) (b : bool) : bool by wf b lt_tf :=
  bbij bij_true true := bij_true ;
  bbij bij_true false := negb (bbij bij_true true).


(** Working with MetaCoq **)

(** Below you will find an introduction to MetaCoq.

    We will not go into the detail of everything so just keep going and see it
    a bit in action.
**)

From MetaCoq.Template Require Import All.
(* Import MCMonadNotation. *)
(* Open Scope bs. *)
Require Import String.
Open Scope string_scope.
(** Here is the type of Coq terms, within Coq. I don't expect you to understand
    it completely of course. We'll look at examples rigth after.
**)
Print term.

(** The following command will "quote" the term λx.x and give you its
    corresponding syntax.

    Don't worry too much about understanding all the details. You should be able
    to recognise the rough syntax of the Coq terms even if it's very verbose.

    Once again, if you're using VSCoq, this will appear in the Info output.
**)
MetaCoq Test Quote (λ (x : nat), x).

(* Here it shows the following term. *)
Check (
  tLambda {| binder_name := nNamed "x"; binder_relevance := Relevant |}
    (tInd {|
      inductive_mind := (MPfile ["Datatypes"; "Init"; "Coq"], "nat");
      inductive_ind := 0
    |} [])
    (tRel 0)
).

(* Another example *)
MetaCoq Test Quote ((λ x, x) 0).

(* This time we get *)
Check (
  tApp (
    tLambda {| binder_name := nNamed "x"; binder_relevance := Relevant |}
      (tInd {|
        inductive_mind := (MPfile ["Datatypes"; "Init"; "Coq"], "nat");
        inductive_ind := 0
      |} [])
      (tRel 0)
  ) [
    tConstruct {|
      inductive_mind := (MPfile ["Datatypes"; "Init"; "Coq"], "nat") ;
      inductive_ind := 0
    |} 0 []
  ]
).

(* We can also go back from syntax to actual Coq terms. *)
(* Provided the definition we give is correct. *)

MetaCoq Test Unquote (
  tConstruct (mkInd (MPfile ["Datatypes"; "Init"; "Coq"], "nat") 0) 0 []
).

(** We don't have to understand everything that's happening.
    For instance, to write a big term, we can ask MetaCoq to generate the
    smaller bits for us.
**)

MetaCoq Quote Definition tNat := nat.
Print tNat.

MetaCoq Quote Definition tZero := 0.

(* Now we have terms that correspond to the syntax of nat and 0. *)

(* I also give you this for binders: *)
Notation bnamed x := {|
  binder_name := nNamed x ;
  binder_relevance := Relevant
|}.
(* Now we don't have to worry about them. *)

(* A small defect, you need parentheses around the definition to unquote. *)
MetaCoq Unquote Definition idNat :=
  (tLambda (bnamed "toto") tNat (tRel 0)).
  (** tRel 0 is a so-called de Bruijn index: it refers to the latest
      variable introduced in the context, so here "toto".
  **)

Print idNat.

MetaCoq Unquote Definition idNat_0 := (
  tApp (tLambda (bnamed "toto") tNat (tRel 0)) [ tZero ]
).

Print idNat_0. (* It seems that Unquote performed some simplification. *)

(* Now look what happens if you quote again idNat *)
(* Are we getting the same syntax as before? *)
MetaCoq Quote Definition idNat_syntax_or_is_it := idNat.
Print idNat_syntax_or_is_it.

(** The answer is no.
    We're getting a reference to the definition rather than the definition
    itself.
    We can still recover the definition itself as follows:
**)

MetaCoq Quote Definition idNat_syntax :=
  Eval unfold idNat in idNat.

Print idNat_syntax.

(* There exists yet another way to quote a term conveniently. *)

MetaCoq Unquote Definition idNat_0' := (
  tApp (tLambda (bnamed "toto") <% nat %> (tRel 0)) [ <% 0 %> ]
).

MetaCoq Unquote Definition idNat_0'' := (
  tApp <% idNat %> [ <% 0 %> ]
).

Print idNat_0''. (* Here you see the advantage of quoting idNat as a name. *)

Fail MetaCoq Unquote Definition idNat_0''' := (
  tApp <% λ x, x %> [ <% 0 %> ]
). (* Sadly we can't write this, Coq can't infer things properly *)

(* With some more annotation, it's fine. *)
MetaCoq Unquote Definition idNat_0''' := (
  tApp <% λ (x : nat), x %> [ <% 0 %> ]
).
Print idNat_0'''.

(* One more example: one *)

MetaCoq Unquote Definition one := (
  tApp <% S %> [ <% 0%> ]
).
Print one.

(** Meta-programming is about manipulating programs so let's do that.
    We can write functions we would not be able to write in Coq.
    We will define a function that behaves differently on true, false
    and on any other construction of type bool (such as a variable).

    First we get the syntax of true and false to understand it better.
**)

MetaCoq Quote Definition true_syntax := true.
Print true_syntax.

(* Once again a notation to make things easier to read and write. *)
Notation bool_name := (MPfile ["Datatypes"; "Init"; "Coq"], "bool").

Print true_syntax.

MetaCoq Quote Definition false_syntax := false.
Print false_syntax.

(** The difference in representation between true and false lies in the last
    natural number: it says which constructor we refer to.
**)

Definition not_quite_negb (b : term) : term :=
  match b with
  | tConstruct {| inductive_mind := bool_name ; inductive_ind := 0 |} 0 [] => <% false %>
  | tConstruct {| inductive_mind := bool_name ; inductive_ind := 0 |} 1 [] => <% true %>
  | _ => b
  end.

MetaCoq Unquote Definition negb_true := (
  not_quite_negb <% true %>
).
Print negb_true.

MetaCoq Unquote Definition negb_false := (
  not_quite_negb <% false %>
).
Print negb_false.

Definition true' := true.

MetaCoq Unquote Definition negb_true' := (
  not_quite_negb <% true' %>
).
Print negb_true'.

(** Here we see different behaviours on true and true' even though they
    are convertible. MetaCoq sees a difference syntactically.
**)

(** Can you write a similar function on natural numbers?
    One that sends S n to n, 0 to true (why not?) and all other terms to
    themselves.
**)

Notation nat_name := (MPfile ["Datatypes"; "Init"; "Coq"], "nat").

Definition removeS_or_true (t : term) : term := 
  match t with 
  |tApp <% S %> [ <% 0 %> ] => <% 0 %>
  |tRel <% 0%> => <% true %>
  |_ => t
  end.

  Check  (removeS_or_true <%(S 0)%>).

(* Test it on a few examples, not necessarily of type nat *)

(** In order to do some interesting stuff, let us look at how
    inductive types are represented. If you print tNat, you will see that it
    is mostly just a name. We want to know its constructors!

    In order to print it we use a more flexible command called MetaCoq Run.
    It allows us to run programs that access and manipulate the environment.

    We use the tmQuoteInductive command to get back the syntax of nat as
    nat_syn. The we give it to tmPrint that will print it (in the Info output).
**)

MetaCoq Run (
  nat_syn <- tmQuoteInductive nat_name ;;
  tmPrint nat_syn
).

(* If the Info output is inconvenient, then let's put it in a definition. *)

MetaCoq Run (
  nat_syn <- tmQuoteInductive nat_name ;;
  tmDefinition "nat_syn" nat_syn
).
Print nat_syn.

(** That's a lot of information!
    This is in part because inductive types can be mutually defined. Also this
    syntax is shared with records and coinductive types. We can safely ignore
    most of it.

    The field we care about is ind_bodies which is the list of mutually defined
    inductive types. For nat there is only one so the list contains only one
    element.
    For it we have the field ind_type which containts (the syntax of) the type
    of nat, here essentially Type.
    The other interesting field is ind_ctors which contains a list of
    constructors. Constructors come with a name (cstr_name), a type (cstr_type),
    and a list of arguments (cstr_args).
    You may notice how the type of 0 is said to be tRel 0, ie a variable.
    This is because nat is what we're currently defining so it can't mention
    itself yet. Instead, constructors are defined in the context (nat : Type).
    In other words tRel 0 refers to nat.
**)

(* Exercise, get the syntax of bool as a definition bool_syn. *)

(* Of course, you won't be using Definition. *)
Definition bool_syn : mutual_inductive_body := exercise.

(** Can you now write a function that adds a constructor to an inductive
    definition? Let's do it first for a one_inductive_body, ie the definition
    of one inductive among a mutual block.
*)

(* First, we give you a function to rename constructors and inductive types. *)

Definition translate_ident (x : ident) : ident :=
  x ++ "_x".

(* Write a function that applies this to the name of a constructor. *)

Definition translate_constructor_body (c : constructor_body) : constructor_body :=
  exercise.

(** You can use the following function for defining a constructor from
    a term corresponding to the expected type.
    Don't worry too much about the definition. It is mostly about getting the
    right information in the right place.
**)

Definition remove_last_n {A} (l : list A) (n : nat) : list A :=
  firstn (#|l| - n) l.

Fixpoint try_remove_n_lambdas (n : nat) (t : term) {struct n} : term :=
  match n, t with
  | 0, _ => t
  | S n, tLambda _ _ t => try_remove_n_lambdas n t
  | S _, _ => t
  end.

Definition make_constructor mind (cname : ident) (ctype : term) : constructor_body :=
  let n := #|ind_bodies mind| in
  let typ := try_remove_n_lambdas n ctype in
  let '(args, concl) := decompose_prod_assum [] typ in
  let (hd, indices) := decompose_app concl in
  {|
    cstr_name := cname ;
    cstr_args := remove_last_n args #|mind.(ind_params)| ;
    cstr_indices := skipn mind.(ind_npars) indices ;
    cstr_type := typ ;
    cstr_arity := context_assumptions args
  |}.

(* Now you can write the operation that adds the constructor *)
(* Remember that it should also rename things. *)

Definition add_ctor (mind : mutual_inductive_body) (ind : one_inductive_body) (cname : ident) (ctype : term) :
  one_inductive_body := exercise.

(** We can now apply this to a mutual inductive body, say by extending the
    first inductive of the list.
**)

Definition add_ctor_mind (mind : mutual_inductive_body) (cname : ident) (ctype : term) : mutual_inductive_body :=
  exercise.

(** You can test it on bool and nat as follows
    (remove Fail once the above is defined).
**)

Fail MetaCoq Run (
  tmMkInductive' (add_ctor_mind nat_syn "SS" <% λ (indty : Type), indty → indty %>)
).
Fail Print nat_x.

Fail MetaCoq Run (
  tmMkInductive' (add_ctor_mind bool_syn "unknown" <% λ (indty : Type), indty %>)
).
Fail Print bool_x.

(* We can even define a nice meta-program to do it faster *)

Definition add_constructor (ind : term) (name : ident) (type : term) :=
  match ind with
  | tInd i _ =>
    mind <- tmQuoteInductive (inductive_mind i) ;;
    tmMkInductive' (add_ctor_mind mind name type)
  | _ => tmFail "Not an inductive"
  end.

Fail MetaCoq Run (
  add_constructor <% unit %> "iambool" <% λ (T : Type), T %>
).
Fail Print unit_x.

(* This one is supposed to fail, 0 isn't an inductive type. *)
Fail MetaCoq Run (
  add_constructor <% 0 %> "iambool" <% λ (T : Type), T %>
).

(** The above was a simplified version of
    https://github.com/MetaCoq/metacoq/blob/coq-8.16/examples/add_constructor.v
    if you want to know more.

    Another cool example is a tactic written in MetaCoq:
    https://github.com/MetaCoq/metacoq/blob/coq-8.16/examples/constructor_tac.v
**)

(** Back to Ltac: using terms in tactics.

  In the project you might have seen a puzzling constr:() notation.
  It lets you build Coq terms directly in Ltac.

  Consider the following (artificial) example.

**)

Goal True.
Proof.
  let t := constr:(24) in
  pose (x := t).
Abort.

(** Maybe all three elements are new, let's go over them:
    - You can use let in Ltac to define some objects to use later, even tactics.
    - The use of constr:() to tell Ltac that 24 is a Coq term and not a tactic.
    - The pose tactic that lets you put a definition in the context.

    For the next example, I will introduce yet another tactic: specialize.
    specialize (h a) lets you update an hypothesis h to replace it with itself
    applied to a (so h a). Let's see it in action.
**)

Goal (∀ (n m : nat), n = m) → False.
Proof.
  intro h.
  specialize (h 0).
  specialize (h 1).
  discriminate.
Restart.
  (* We can also give several arguments at once. *)
  intro h.
  specialize (h 0 1).
  discriminate.
Qed.

(** Before we get to the exercise, let me show you one last thing: type of.
    In Ltac you can examine the goal using (lazy)match goal, or even a term
    t wiht (lazy)match t, but you can also examine the type of a term t
    using (lazy)match type of t.

    The following tactic specializes one hypothesis in the context with its
    argument a.
**)

Ltac specialize_one_with a :=
  lazymatch type of a with
  | ?T =>
    lazymatch goal with
    | h : ∀ (x : T), _ |- _ => specialize (h a)
    end
  end.

Lemma test_specialize_one_with :
  (∀ b, b = true && b)%bool →
  (∀ n, n = n + 0) →
  (∀ t, t = tt) →
  (∀ a, (a, 0) = (0, a)) →
  True.
Proof.
  intros hb hn ht hp.
  specialize_one_with false.
  specialize_one_with tt.
  specialize_one_with 1.
  specialize_one_with 1.
  (** Here you can see it starts by looking at the most recent hypothesis in
      scope. This is always the case so you can make use of this information.
  **)
Abort.

(** Now, you can use a combination of constr:, type of and specialize to create
    a tactic that takes an hypothesis h of type ∀ n₀ … nₖ, P n₀ … nₖ and
    specializes it to P 0 … k.
**)

Ltac inst_hyp h n :=
  exercise.

Lemma test_inst_hyp :
  (∀ x y z, x + y + z = 0) →
  False.
Proof.
  intro h.
  inst_hyp h 0.
  Fail discriminate. (* This should not fail when you're done. *)
Qed.

(** As I said, you can also match on term to compute a tactic with it.
    Try to write a tactic that takes a natural number n and a tactic t and
    applies t exact n times. In other words ntimes 3 t should be the same as
    t ; t ; t.
**)

Ltac ntimes n t :=
  idtac.

Goal 15 = 15.
Proof.
  (* This just applies congruence of S *)
  apply (f_equal S).
  (* Now we apply it a certain number of times. *)
  let t := (apply (f_equal S)) in
  let n := constr:(4) in
  ntimes n t.
  (* We can also try to use n from the context but it shoudl fail. *)
  pose (n := 5).
  (* Fail *) let t := (apply (f_equal S)) in
  ntimes n t.
  (** Maybe you can make it so there is a nice error message using
      fail "error_msg". Also add Fail if you want to keep playing.
  **)
Abort.

(** Actually there is already a tactic for this called do and it doesn't
    require the constr:() as it uses int of Ltac.
**)

(* If you finished early, you can always go and finish last's week exercises. *)